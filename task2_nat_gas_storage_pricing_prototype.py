#!/usr/bin/env python3
"""storage_pricing_prototype.py

Prototype pricing model for a simple gas storage-like contract.
- Simulates execution of injection/withdrawal events at specified dates and amounts.
- Applies per-event injection/withdrawal rate caps and a storage capacity constraint.
- Computes cashflows (buys = negative, sells = positive) and accrues storage costs between events.
- Uses a provided daily price lookup (a pandas Series indexed by dates) or explicit per-event prices.

Outputs a detailed breakdown and a single scalar "contract value" (net cashflow minus storage costs).

Author: Generated by ChatGPT (prototype)
"""

from datetime import datetime, timedelta, date
import numpy as np
import pandas as pd
import json
import os

def parse_date(d):
    if isinstance(d, (datetime, date)):
        return pd.Timestamp(d).normalize()
    return pd.to_datetime(d).normalize()

def build_daily_price_series_from_artifact(npz_path='/mnt/data/nat_gas_model_artifacts.npz'):
    """Load monthly dates/prices from artifact npz and return a daily-interpolated pandas Series."""
    if not os.path.exists(npz_path):
        raise FileNotFoundError(f"Artifact file not found: {npz_path}. Run the model that creates this artifact first.")
    arr = np.load(npz_path, allow_pickle=True)
    monthly_dates = arr['monthly_dates'].astype(str)
    monthly_prices = arr['monthly_prices'].astype(float)
    idx = pd.to_datetime(monthly_dates)
    s = pd.Series(monthly_prices, index=idx).sort_index()
    daily_idx = pd.date_range(start=s.index.min(), end=s.index.max(), freq='D')
    daily = s.reindex(daily_idx).interpolate(method='time')
    return daily

def price_storage_contract(injection_schedule, withdrawal_schedule,
                           price_lookup=None,
                           max_injection_rate=np.inf, max_withdrawal_rate=np.inf,
                           max_volume=np.inf, storage_cost_per_unit_per_day=0.0,
                           starting_inventory=0.0):
    """
    Parameters
    - injection_schedule: list of (date, requested_amount) where requested_amount > 0 (units of commodity)
    - withdrawal_schedule: list of (date, requested_amount) where requested_amount > 0 (units to withdraw/sell)
    - price_lookup: either a function(price_date) -> price or a pandas Series indexed by dates (will be interpolated)
    - max_injection_rate / max_withdrawal_rate: per-event cap (same time granularity as events)
    - max_volume: storage capacity (max inventory)
    - storage_cost_per_unit_per_day: cost per unit held per day
    - starting_inventory: initial inventory level (default 0)

    Returns dict with details:
      - total_cashflow (sells positive, purchases negative)
      - total_storage_cost
      - net_value (cashflow - storage_cost)
      - per_event_execution list with details for each event
    """
    # Normalize and create unified event list
    events = []
    for d, amt in injection_schedule:
        events.append({'date': parse_date(d), 'type': 'inject', 'requested': float(amt)})
    for d, amt in withdrawal_schedule:
        events.append({'date': parse_date(d), 'type': 'withdraw', 'requested': float(amt)})
    if len(events) == 0:
        return {'total_cashflow': 0.0, 'total_storage_cost': 0.0, 'net_value': 0.0, 'events': []}

    # Sort events by date (stable)
    events.sort(key=lambda x: x['date'])

    # Prepare price lookup function
    if isinstance(price_lookup, pd.Series):
        # ensure daily index and interpolation
        daily = price_lookup.sort_index()
        if daily.index.freq is None:
            # interpolating as needed; reindex to daily
            daily = daily.reindex(pd.date_range(daily.index.min(), daily.index.max(), freq='D')).interpolate(method='time')
        def _price_on(d):
            ts = pd.Timestamp(d).normalize()
            if ts < daily.index.min() or ts > daily.index.max():
                # allow extrapolation via nearest
                if ts < daily.index.min():
                    return float(daily.iloc[0])
                else:
                    return float(daily.iloc[-1])
            return float(daily.loc[ts])
    elif callable(price_lookup):
        _price_on = price_lookup
    else:
        # If None, raise error
        raise ValueError('price_lookup must be a pandas Series or a callable(date)->price')

    # Simulation variables
    inventory = float(starting_inventory)
    last_date = events[0]['date']
    total_cashflow = 0.0
    total_storage_cost = 0.0
    executed_events = []

    for ev in events:
        cur_date = ev['date']
        # accrue storage cost from last_date (post-action inventory held during (last_date, cur_date] )
        days = (cur_date - last_date).days
        if days > 0:
            cost = storage_cost_per_unit_per_day * inventory * days
            total_storage_cost += cost
        # Determine execution amount limited by rate and capacity/inventory
        requested = ev['requested']
        if ev['type'] == 'inject':
            allowed_by_rate = min(requested, float(max_injection_rate))
            allowed_by_capacity = max_volume - inventory
            executed = max(0.0, min(allowed_by_rate, allowed_by_capacity))
            price = _price_on(cur_date)
            cashflow = - executed * price  # buying => negative
            inventory += executed
            unfilled = requested - executed
            note = ''
            if unfilled > 1e-9:
                note = f'unfilled_amount={unfilled:.6f} (rate/capacity limited)'
        else:  # withdraw
            allowed_by_rate = min(requested, float(max_withdrawal_rate))
            allowed_by_inventory = inventory
            executed = max(0.0, min(allowed_by_rate, allowed_by_inventory))
            price = _price_on(cur_date)
            cashflow = executed * price  # selling => positive
            inventory -= executed
            unfilled = requested - executed
            note = ''
            if unfilled > 1e-9:
                note = f'unfilled_amount={unfilled:.6f} (rate/inventory limited)'

        total_cashflow += cashflow
        executed_events.append({
            'date': pd.Timestamp(cur_date).date().isoformat(),
            'type': ev['type'],
            'requested': requested,
            'executed': executed,
            'price': float(price),
            'cashflow': float(cashflow),
            'inventory_after': float(inventory),
            'note': note
        })

        last_date = cur_date

    # No further storage cost after last event assumed.

    return {'total_cashflow': float(total_cashflow),
            'total_storage_cost': float(total_storage_cost),
            'net_value': float(net_value),
            'events': executed_events}

# If run as script, demonstrate example usage
if __name__ == '__main__':
    print('Running demo of storage_pricing_prototype...')
    try:
        daily_prices = build_daily_price_series_from_artifact()
    except Exception as e:
        print('Could not load artifact for price series (this demo will use dummy prices). Error:', e)
        # Build a simple flat daily price series as fallback
        dindex = pd.date_range('2024-01-01', periods=365, freq='D')
        daily_prices = pd.Series(10.0 + 0.01 * np.sin(np.arange(len(dindex))/20.0), index=dindex)

    # Sample scenario
    injection_schedule = [('2024-10-15', 100.0), ('2025-01-15', 50.0)]
    withdrawal_schedule = [('2025-03-15', 120.0), ('2025-09-30', 30.0)]
    res = price_storage_contract(injection_schedule, withdrawal_schedule,
                                 price_lookup=daily_prices,
                                 max_injection_rate=200.0, max_withdrawal_rate=200.0,
                                 max_volume=200.0, storage_cost_per_unit_per_day=0.001,
                                 starting_inventory=0.0)
    print('\nResult (summary):')
    print(json.dumps({'total_cashflow': res['total_cashflow'],
                      'total_storage_cost': res['total_storage_cost'],
                      'net_value': res['net_value']}, indent=2))
    print('\nEvents:')
    for e in res['events']:
        print(e)
